%% 霍夫曼编码

%% 函数
function [Cm, P1, avlen] = huffman(image)
    %对图像中的每一级灰度进行统计
    [m, n] = size(image);%得到图像的大小，行数和列数
    nums = imhist(image)';
    %得到每一级灰度的出现概率，降序排序
    P = sort(nums / (m * n), 'descend');
    T = P;
    [~ ,k] = size(P);
    B = zeros(k, k-1); %空的编码表矩阵
    B(:, 1) = T;   %生成编码表的第一列
    r = B(k, 1) + B(k - 1, 1); %最后两个元素相加
    T(k - 1) = r;
    T(k) = 0;
    T = sort(T, 'descend');

    t = k - 1;
    for j = 2 : k - 1   %生成编码表的其他各列
        B(1 : t, j) = T(1 : t);
        K = find(T == r);   %取T矩阵中为r的索引值，及下标位置
        % B(n,j)=K(end); %从第二列开始，每列的最后一个元素记录特征元素在该列的位置,概率之和往下排
        B(k, j) = K(1);   %从第二列开始，每列的最后一个元素记录特征元素在该列的位置,概率之和往上排
        r = (B(t - 1, j) + B(t, j));  %最后两个元素相加
        T(t - 1) = r;
        T(t) = 0;
        T = sort(T, 'descend');
        t = t - 1;
    end

    %B为输出编码表
    ENDc1 = {'1', '0'};%第(n-1)级从上到下按1，0赋值编码
    ENDc = ENDc1;    %存码字
    t = 3;%在j=n-2，即第(n-2)列时，只有三个有效概率，即有值的概率
    d = 1;
    for j = k - 2 : -1: 1  %从倒数第二列开始依次对各列元素编码
        for i = 1 : t - 2 %每级从第一行开始。该循环完成继承编码工作，即图形上跨列相等概率的长直线
            if i> 1 && B(i,j) == B(i - 1, j)%若i>1且在第J列时，有第i行与(i-1)行值相等，则第i行时42行继承第二个相等的值，因为这两个值都是可以由后一级继承的。在第J列时，第i行在(i-1)行下面一位，在第J+1列时同样
                 d = d + 1;
            else
                d = 1;%若i>1且在第J列时，没有相等，则42行直接继承
            end
            B(B(k, j + 1),j + 1) = -1;  %B(n,j+1)为最后一行的数，即前面记录的相加后数的下标
            temp = B(:, j + 1);%选取后一级所有元素
            x = find(temp == B(i, j));%从矩阵最右端(n-1)开始，找前一级的前(t-2)位分别对应于后一级的第几位，每级从第一行开始。为什么选前(t-2)位呢？因为第t位为最后一位有效概率，倒数第一二位要相加求和
            ENDc(i) = ENDc1(x(d)); %继承上一级相等处的编码，即图形中表示同一概率的长横线
        end

        %该循环完成相加求和部分的编码工作，即图形上跨列不相等概率的长直线
        y = B(k, j + 1);%取出前一级的低D位加和对应于后一级的第几位的索引值，前一级相加后索引值的存放在后一级
        ENDc(t - 1) = strcat(ENDc1(y), '1');%每一级的第(t-1)位，即用于相加的第一位，编码尾后加'1'，也即每一级的倒数第二位
        ENDc(t) = strcat(ENDc1(y), '0');%每一级的第t位，即用于相加的第二位，编码尾后加'0'，也即每一级的倒数第一位
        t = t + 1;%当列数从j=n-2到1时，t每级加一，即每一列存在的有效概率每级加一
        ENDc1 = ENDc;%第(n-1)级之前的，每级用后一级的编码迭代
    end
    
    L = zeros(1, k);
    for i = 1 : k
        [~, b] = size(char(ENDc(i)));%每位数据转为char型，size后即每个i对应于1行，码长列的矩阵
        L(i) = b;%取b即取码长
    end
    
    avlen = sum(L.*P);  %平均码长，码长乘以概率求和

    T = P(find(P ~= 0));
    H = -sum(T .* log2(T));
    
    P1 = H / avlen ; %信息传输率 = 熵 / 平均码长
    Cm = ENDc;
end